# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_schedules.ipynb.

# %% auto 0
__all__ = ['name2schedule', 'num_steps', 'baseline_g', 'max_val', 'min_val', 'num_warmup_steps', 'warmup_init_val', 'num_cycles',
           'k_decay', 'invert_k_sched', 'DEFAULT_SCHED_PARAMS', 'T_max_val', 'T_min_val', 'DEFAULT_T_PARAMS',
           'GuidanceSchedule', 'ConstantGuidanceSchedule', 'LinearGuidanceSchedule', 'CosGuidanceSchedule',
           'get_cos_sched', 'get_linear_sched']

# %% ../nbs/03_schedules.ipynb 3
import math 

# %% ../nbs/03_schedules.ipynb 4
class GuidanceSchedule:
    def __init__(self, default_kwargs=DEFAULT_SCHED_PARAMS):
        self.sched_kwargs = dict(default_kwargs)
        self.values = []
        
    def set_num_steps(self, num_steps):
        """Needed for 2+ step schedulers and samplers
        """
        self.sched_kwargs.update({'num_steps': num_steps})
        
    def update_sched_kwargs(self, other_kwargs):
        if 'num_steps' in other_kwargs:
            print(f'Warning: removing number of steps from sched_kwargs.')
            del other_kwargs['num_steps']
        self.sched_kwargs.update(other_kwargs)
        
    def set_guidance_schedule(self):
        raise NotImplementedError

    def value_at(self, idx=None):
        return self.values[int(idx)]

    def __getitem__(self, idx):
        return self.value_at(idx)


class ConstantGuidanceSchedule(GuidanceSchedule):
    """Baseline Classifier-free Guidance with a constant update.
    """
    def set_guidance_schedule(self):
        sched = [self.sched_kwargs['max_val'] for _ in range(self.sched_kwargs['num_steps'])]
        self.values = sched


class LinearGuidanceSchedule(GuidanceSchedule):
    """Linear schedule for Classifier-free Guidance, with optional warmup.
    """
    def set_guidance_schedule(self):
        sched = get_linear_sched(**self.sched_kwargs)
        self.values = sched


class CosGuidanceSchedule(GuidanceSchedule):
    """Cosine schedule for Classifier-free Guidance.
    """
    def set_guidance_schedule(self):
        sched = get_cos_sched(**self.sched_kwargs)
        # invert k-decay schedules when k is less than one
        if (self.sched_kwargs['k_decay'] < 1) and self.sched_kwargs.get('invert_k_sched'):
            sched = [self.sched_kwargs['max_val'] - g + self.sched_kwargs['min_val'] for g in sched]
        self.values = sched
    

'''Map from string name to guidance schedule class.
'''  
name2schedule = {
    'constant': ConstantGuidanceSchedule,
    'linear': LinearGuidanceSchedule,
    'cos': CosGuidanceSchedule,
}

# %% ../nbs/03_schedules.ipynb 5
# Default schedule parameters
######################################
######################################
num_steps         = 50   # the default number of steps, matching `diffusers` API
baseline_g        = 8    # default, static guidance value
max_val           = 9    # the max scheduled guidance scaling value
min_val           = 6    # the minimum scheduled guidance value
num_warmup_steps  = 0    # number of warmup steps
warmup_init_val   = 0    # the initial warmup value
num_cycles        = 0.5  # number of cosine cycles
k_decay           = 1    # k-decay for cosine curve scaling 
invert_k_sched    = True # whether to invert small k schedules

# group the default schedule parameters
DEFAULT_SCHED_PARAMS = {
    'max_val':           max_val,
    'num_steps':         num_steps,
    'min_val':           min_val,
    'num_cycles':        num_cycles,
    'k_decay':           k_decay,
    'invert_k_sched':    invert_k_sched,  
    'num_warmup_steps':  num_warmup_steps,
    'warmup_init_val':   warmup_init_val,
}

# smaller values for T-norm
T_max_val = 0.3
T_min_val = 0.15
DEFAULT_T_PARAMS = dict(DEFAULT_SCHED_PARAMS)
DEFAULT_T_PARAMS.update({'max_val': T_max_val, 'min_val': T_min_val})
######################################
######################################


def get_cos_sched(num_steps: int = 50,
                  max_val: float = 7.5,
                  min_val: float = 0.15,
                  num_cycles: float = 0.5,
                  num_warmup_steps: int = 0,
                  warmup_init_val: float = 0.,
                  k_decay:float = 1.,
                  cycle_mul: float = 1.,
                  cycle_decay:float = 1.,
                  cycle_limit = 1.,
                  **kwargs) -> list:
    '''Creates a cosine schedule based on the given parameters.
    
    Args:
        num_steps: Number of total steps in the schedules. 
        max_val: The maximum value in the schedule. 
        min_val: The minimum number in the schedule. 
        num_cycles: How many full cosine schedules to sweep. By default, 0.5.
        num_warmup_steps: Over how many steps to warmup.  
        cycle_mul: Param for timm scheduler.
        cycle_decay: Param for timm schedulers.
        cycle_limit: Param for timm schedulers.
        k_decay: Param for timm schedulers.  
        
    The cycle_* and k_decay `timm` parmeters are described in better detail here:
        https://timm.fast.ai/SGDR#CosineLRScheduler
    These args offer a lot of powerful flexibility in guiding the cosine scheduler.
        TODO: experiment with these settings for diffusion.  
        
    NOTE: cycle_* parameters might not work as intended, since we are dealing with "one" epoch.
    
    Based on a combo of HuggingFace and timm schedulers:
        https://github.com/rwightman/pytorch-image-models/blob/main/timm/scheduler/cosine_lr.py
        https://github.com/huggingface/transformers/blob/v4.24.0/src/transformers/optimization.py#L104
    '''

    def cos_sched_helper(current_step):
        "Helper to compute cosine values."
        
        # get the warmup values
        if current_step < num_warmup_steps:
            init_offset = float(current_step * (max_val - warmup_init_val)) / float(max(1, num_warmup_steps))
            return warmup_init_val + init_offset
        
        # get the regular scheduled values
        else:

            if cycle_mul != 1:
                i = math.floor(math.log(1 - current_step / num_steps * (1 - cycle_mul), cycle_mul))
                t_i = cycle_mul ** i * num_steps
                t_curr = current_step - (1 - cycle_mul ** i) / (1 - cycle_mul) * num_steps
            else:
                i = current_step // num_steps #
                t_i = num_steps
                t_curr = current_step - (num_steps * i)

            # find the scaled maximum value based on cycle_decay
            gamma = cycle_decay ** i
            scaled_max = max_val * gamma
            scaled_mag = 0.5 * (scaled_max - min_val)
            
            # find completion offset based on current step and k-decay
            t_curr = (t_curr - num_warmup_steps)
            t_i = max(1, num_steps - num_warmup_steps)
            scaled_progress = (t_curr ** k_decay) / (t_i ** k_decay)
            
            if i < cycle_limit:
                cos_val = (1 + math.cos(math.pi * 2 * num_cycles * scaled_progress))
                val = min_val + scaled_mag * cos_val
            else:
                val = min_val

            return val

    # get the schedule values for each timestep
    schedule = [cos_sched_helper(i) for i in range(num_steps)]
    return schedule


def get_linear_sched(num_steps: int = 50,
                     num_warmup_steps: int = 0,
                     min_val: float = 0.,
                     max_val: int = 9,
                     **kwargs) -> list:
    def linear_sched_helper(current_step: int):
        """Linear schedule with potential offset for min or warmup value."""
        if current_step < num_warmup_steps:
            init_offset = float(current_step * (max_val - min_val)) / float(max(1, num_warmup_steps))
            return min_val + init_offset
        return max(
            0.0, min_val + (max_val - min_val) * (float(num_steps - current_step) / float(max(1, num_steps - num_warmup_steps)))
        )

    schedule = [linear_sched_helper(i) for i in range(num_steps)]
    return schedule
